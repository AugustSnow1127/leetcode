/*
 * @lc app=leetcode id=136 lang=javascript
 *
 * [136] Single Number
 */

// @lc code=start
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    let res = 0;

    for (let n of nums) {
        res = res ^ n;
    }

    return res;
};
// @lc code=end

/**
 * 思考
 * 1. 這題的重點是有O(n)時間複雜度的限制和O(1)的空間複雜度限制
 * [叫AI給我位元相關的指令]
 * 1. AND (&) - 取出/檢查特定位元
功能：兩個位元都是 1，結果才是 1。
用途：
檢查奇偶數：n & 1。如果結果是 1，表示是奇數；0 是偶數（比 % 2 快）。
遮罩 (Masking)：想保留某些位元，清空其他位元。例如 x & 00001111 只保留最後 4 位。
判斷某個位元是否為 1：(target & (1 << k))，檢查第 k 個位元是不是 1。
2. OR (|) - 設定特定位元
功能：只要有一個是 1，結果就是 1。
用途：
強制設為 1：把某個位元「打開」。例如 x | (1 << k) 可以把第 k 個位元強制變成 1，不管它原本是什麼。
3. XOR (^) - 翻轉位元 / 找不同
功能：相同為 0，不同為 1。
用途：
找落單的數（像 LeetCode 136）。
不使用暫存變數交換兩個數：a = a ^ b; b = a ^ b; a = a ^ b;。
翻轉特定位元 (Toggle)：想要把第 k 位元 0 變 1、1 變 0，就用 x ^ (1 << k)。
4. NOT (~) - 反轉所有位元
功能：0 變 1，1 變 0。
用途：
通常配合 & 使用來「關掉」某個位元。例如 x & ~(1 << k) 可以把第 k 個位元強制設為 0。
5. Shift 左移 (<<) 與 右移 (>>)
功能：把所有位元向左或向右移動。
用途：
快速乘除 2 的次方：
n << 1 等於 n * 2
n << k 等於 n * (2^k)
n >> 1 等於 n / 2 (整除)
存取第 k 個位元：也就是上面常看到的 1 << k，這是產生「只有第 k 位是 1」的標準動作。

 * 2. 只需要找到烙單的值，所以可以利用XOR的特性找出唯一相異的值
 */