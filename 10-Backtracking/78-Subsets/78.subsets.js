/*
 * @lc app=leetcode id=78 lang=javascript
 *
 * [78] Subsets
 */

// @lc code=start
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
    // 為了遞迴遍歷"選"和"不選"，需要向葉節點移動一個function
    const res = []; // 放答案
    const set = [];

    // 需要的參數
    // 1. 當前的陣列存到哪裡
    // 2. 下一個要檢視的index
    const add = (currSet, index) => {
        const num = nums[index];

        // 如果沒有下一個數字就回傳答案
        if (index == nums.length) {
            res.push([...currSet]);
        } else {
            // 選
            currSet.push(num);
            add(currSet, index + 1);
            
            // 不選
            currSet.pop();
            add(currSet, index + 1);
        }

    }

    add(set, 0);

    return res;
};

// @lc code=end

/**
 * 思考
 * [問AI什麼是backtracking] 
 * Step 1: 理解 Backtracking 的本質
Backtracking = 試錯 + 回溯

想像你在走迷宮，走到死路就往回走，然後試另一條路。

引導問題 1：在你的決策樹中，當你走到某個節點（例如「選了 1，選了 2」），你要怎麼「試」下一個選項？

Step 2: 函式參數設計
對於這題，你的遞迴函式需要知道什麼資訊才能做事？

引導問題 2：試著想，這個函式需要接收：

目前累積的子集？（例如 [1,2]）
處理到哪個數字了？（例如索引 i，代表該處理 nums[i] 了）
還有什麼需要的嗎？

Step 3: 終止條件
引導問題 3：什麼時候你應該「停下來」並把目前的結果加入答案？

提示：如果你已經處理完所有數字了，是不是就該停止了？

Step 4: 做選擇
當你在某個節點時，對當前的數字 nums[i]，你有兩個選擇：

引導問題 4：

選擇一：把 nums[i] 加入目前子集 → 然後你該怎麼做？該呼叫下一層遞迴嗎？
選擇二：不加入 nums[i] → 然後你該怎麼做？
Step 5: 回溯（關鍵！）
這是 backtracking 最重要的一步。

引導問題 5：當你「選擇一」把 nums[i] 加入子集，處理完之後，為什麼要把它移除？

提示：如果你不移除，當你回到上一層去試「選擇二」時，你的子集會變成什麼樣子？

試著回答這些問題，我會根據你的回答繼續引導。
 * 1. 選剩下沒選的
    2. 還需要一個該選不該選嗎?
        錯，只需要當前子集和待處理索引
    3. 最後的子集長度等於nums長度的時候
        錯，待處理索引等於nums長度的時候就可以停
    4. 加入或不加入後，都繼續往下個節點前進
    5. 不太懂要怎麼回溯，回溯的用意是什麼?

    還是看不太懂回溯，決定看解答

    [看完解答]，只知道就是做一個決策樹，用兩個遞迴做出"要選"和"不選"的選擇，但沒聽懂跟"回溯"這個詞有什麼關聯
    可能回溯是對於"跑程式碼"是回溯的感覺吧，如果是依序執行程式碼，確實是先執行到第一個遞迴結束，才開始第二個遞迴
 */