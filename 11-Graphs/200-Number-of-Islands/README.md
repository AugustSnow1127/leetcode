# Number of Islands
**LeetCode**: #200 | **Difficulty**: Medium |
**Category**: Graphs

## 🔍 Problem Statement
給定一個 `m x n` 的二維矩陣 `grid`，其中 `'1'` 代表陸地，`'0'` 代表水域。

計算網格中島嶼的數量。島嶼是被水（`'0'）包圍的陸地（`'1'），連接方式為水平或垂直方向。

**Example 1:**
```
Input:
grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
```

**Example 2:**
```
Input:
grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3
```

## 💡 解題思路

### 關鍵洞察
- **核心觀察**：島嶼是連通的 `'1'`，可以用 DFS 或 BFS 標記已訪問的陸地
- **問題特徵**：需要遍歷二維網格並找連通分量

### 演算法選擇
- **為什麼選 DFS？**
  - BFS：需要 Queue，實作稍複雜
  - **DFS**：遞迴簡潔，容易實作

- **適用場景**
  - 當需要找圖中的連通分量時
  - 當需要標記已訪問節點時
  - 複雜度分析：時間 O(m * n)，空間 O(m * n)（最壞情況）

### 時機判斷
看到以下特徵時，考慮使用 DFS/BFS：
- 🗺️ 關鍵字：「島嶼」、「連通」、「地區」、「網格」
- 📊 結構：網格或圖形結構
- 🔍 操作：需要標記已訪問節點

## 🎯 實作細節

### 步驟分解

1. **初始化島嶼計數器**：`count = 0`
2. **遍歷整個網格**：
   - 對於每個 `grid[i][j] == '1'`：
     - `count += 1`
     - 呼叫 dfs(i, j) 標記整個島嶼
3. **DFS 標記**：
   - 如果越界或不是 `'1'`，返回
   - 將當前格標記為 `'0'`（或其他已訪問標記）
   - 遞迴標記四個方向（上、下、左、右）

### 關鍵程式碼片段
```python
def numIslands(grid):
    if not grid:
        return 0

    rows, cols = len(grid), len(grid[0])
    count = 0

    def dfs(r, c):
        # 越界或非陸地
        if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == '0':
            return
        # 標記為已訪問
        grid[r][c] = '0'
        # 遞迴四個方向
        dfs(r + 1, c)  # 下
        dfs(r - 1, c)  # 上
        dfs(r, c + 1)  # 右
        dfs(r, c - 1)  # 左

    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                count += 1
                dfs(r, c)

    return count
```

**為什麼這樣寫？**
- 就地修改 grid，不需要額外的 visited 數組
- 四個方向遞迴，標記整個連通分量
- 每個島嶼只訪問一次，O(m * n) 時間

### 易錯點
⚠️ **坑點1**：忘記邊界檢查 - 會導致索引越界
⚠️ **坑點2**：使用額外的 visited 數組 - 浪費空間
⚠️ **坑點3**：遞迴深度過大 - 可能導致堆疊溢出（大網格）

## 📊 複雜度分析

| 方法 | 時間複雜度 | 空間複雜度 | 優點 | 缺點 |
|------|------------|------------|------|------|
| BFS | O(m * n) | O(min(m, n)) | 迭代 | 需要隊列 |
| **DFS** | O(m * n) | O(m * n) | **簡潔** | 堆疊溢出風險 |

## 🤔 相關問題
- [Max Area of Island] - 計算最大島嶼面積
- [Surrounded Regions] - 標記被包圍的地區

## 📝 學習筆記
- **初學重點**：理解網格中的 DFS 遍歷
- **模式識別**：看到「島嶼/連通區域」就想到 DFS/BFS
- **技巧**：就地修改標記訪問，節省空間

## 🔑 關鍵模式
**網格 DFS 模板**
```python
def dfs(r, c):
    # 邊界檢查
    if 越界或不符合條件:
        return
    # 標記已訪問
    grid[r][c] = '0'
    # 遞迴四個方向
    dfs(r + 1, c)
    dfs(r - 1, c)
    dfs(r, c + 1)
    dfs(r, c - 1)
```

## 🎯 追蹤你的進度
- [ ] 完成第一次解題
- [ ] 不看解答重新解題
- [ ] 嘗試 BFS 版本
- [ ] 向他人解釋連通分量的概念

---
**題目連結**: [LeetCode 200](https://leetcode.com/problems/number-of-islands/)
