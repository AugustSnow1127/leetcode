# Clone Graph

## 問題描述

給定一個連通無向圖的參考節點，請深拷貝（Deep Copy）這個圖。
每個節點包含一個值 `val` (`int`) 和鄰居列表 `neighbors` (`List[Node]`)。

## 解題思路：DFS + Hash Map

這題的核心在於如何同時處理「深拷貝」和「圖的環 (Cycle)」。

### 為什麼用 Hash Map？
在圖的遍歷中，因為可能存在環（例如 A-B-A），如果單純遞迴會陷入無窮迴圈。我們需要一個資料結構來記錄：「這個節點我們複製過了嗎？」

- `Key`: 原始圖的節點 (Original Node)
- `Value`: 我們建立的新節點 (Cloned Node)

### 演算法步驟

1. **邊界檢查**：如果輸入是 null，回傳 null。
2. **DFS 遞迴函數**：
   - 輸入一個舊節點。
   - **查表**：如果這個舊節點在 Map 裡，表示已經複製過，直接回傳 Map 裡存的新節點。
   - **建立**：如果沒複製過，建立一個新節點（複製值）。
   - **登記**：**立刻**把 `{舊節點: 新節點}` 存入 Map。這步必須在處理鄰居之前，防止鄰居又連回來時找不到人。
   - **連線**：遍歷舊節點的所有鄰居，對每個鄰居遞迴呼叫 DFS，將回傳的結果加入新節點的 `neighbors` 列表。
   - **回傳**：回傳新建立的節點。

### 複雜度分析

- **時間複雜度**: O(V + E)
  - V 是節點數，E 是邊數。
  - 每個節點只會被處理與建立一次。
  - 每條邊（連線）會被遍歷一次。
- **空間複雜度**: O(V)
  - Hash Map 需要儲存 V 個節點的映射。
  - 遞迴堆疊 (Recursion Stack) 在最差情況下（例如一直線的圖）也是 O(V)。
